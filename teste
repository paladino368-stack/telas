import pandas as pd
import os
from difflib import SequenceMatcher
from typing import Any

def _carregar_dataframe(caminho_arquivo: str, sheet_name: Any = 0) -> pd.DataFrame:
    """
    Carrega dinamicamente um arquivo (CSV ou Excel) em um DataFrame do Pandas.
    Para Excel, permite a especificaÃ§Ã£o da planilha.
    """
    extensao = os.path.splitext(caminho_arquivo)[1].lower()
    print(f"\nğŸ”„ Carregando arquivo: '{os.path.basename(caminho_arquivo)}' (extensÃ£o: {extensao})")

    try:
        if extensao == '.csv':
            return pd.read_csv(caminho_arquivo, low_memory=False)
        elif extensao == '.xlsx':
            return pd.read_excel(caminho_arquivo, sheet_name=sheet_name)
        else:
            raise ValueError(f"ExtensÃ£o '{extensao}' nÃ£o suportada. Use .csv ou .xlsx")
    except FileNotFoundError:
        raise FileNotFoundError(f"ERRO: O arquivo '{caminho_arquivo}' nÃ£o foi encontrado.")
    except Exception as e:
        raise Exception(f"ERRO ao ler o arquivo '{caminho_arquivo}': {e}")

def comparador_avancado_arquivos(
    caminho_arquivo1: str,
    caminho_arquivo2: str,
    sheet1: Any = 0,
    sheet2: Any = 0,
    peso_estrutura: float = 0.3,
    peso_colunas: float = 0.4,
    peso_conteudo: float = 0.3
) -> float:
    """
    Compara de forma avanÃ§ada e totalmente automÃ¡tica a similaridade entre dois arquivos.

    A anÃ¡lise Ã© baseada em trÃªs pilares com pesos ajustÃ¡veis:
    1.  **Estrutura:** Compara a quantidade de linhas e colunas.
    2.  **Nomes das Colunas:** Verifica se o conjunto de colunas Ã© idÃªntico.
    3.  **ConteÃºdo:** Compara cÃ©lula a cÃ©lula o conteÃºdo das colunas em comum.

    Args:
        caminho_arquivo1 (str): Caminho completo para o primeiro arquivo.
        caminho_arquivo2 (str): Caminho completo para o segundo arquivo.
        sheet1 (Any): Planilha a ser lida no primeiro arquivo, se for .xlsx (padrÃ£o 0).
        sheet2 (Any): Planilha a ser lida no segundo arquivo, se for .xlsx (padrÃ£o 0).
        peso_estrutura (float): Peso da similaridade estrutural (padrÃ£o 0.3).
        peso_colunas (float): Peso da similaridade dos nomes das colunas (padrÃ£o 0.4).
        peso_conteudo (float): Peso da similaridade do conteÃºdo (padrÃ£o 0.3).

    Returns:
        float: O percentual final de similaridade entre os dois arquivos.
    """
    print("======================================================")
    print("ğŸš€ INICIANDO COMPARADOR AVANÃ‡ADO DE ARQUIVOS ğŸš€")
    print("======================================================")
    
    try:
        df1 = _carregar_dataframe(caminho_arquivo1, sheet_name=sheet1)
        df2 = _carregar_dataframe(caminho_arquivo2, sheet_name=sheet2)
    except (ValueError, FileNotFoundError, Exception) as e:
        print(f"\nâŒ A anÃ¡lise foi interrompida devido a um erro de carregamento: {e}")
        return 0.0

    # --- 1. ANÃLISE ESTRUTURAL (DIMENSÃ•ES) ---
    print("\n---------- ETAPA 1: ANÃLISE ESTRUTURAL (DIMENSÃ•ES) ----------")
    shape1 = df1.shape
    shape2 = df2.shape
    print(f"DimensÃµes Arquivo 1: {shape1[0]} linhas, {shape1[1]} colunas.")
    print(f"DimensÃµes Arquivo 2: {shape2[0]} linhas, {shape2[1]} colunas.")
    
    sim_linhas = min(shape1[0], shape2[0]) / max(shape1[0], shape2[0]) if max(shape1[0], shape2[0]) > 0 else 1.0
    sim_colunas_total = min(shape1[1], shape2[1]) / max(shape1[1], shape2[1]) if max(shape1[1], shape2[1]) > 0 else 1.0
    score_estrutura = (sim_linhas + sim_colunas_total) / 2
    print(f"ğŸ“Š PontuaÃ§Ã£o de Similaridade Estrutural: {score_estrutura:.2%}")

    # --- 2. ANÃLISE DOS NOMES DAS COLUNAS ---
    print("\n---------- ETAPA 2: ANÃLISE DOS NOMES DAS COLUNAS ----------")
    cols1 = set(df1.columns)
    cols2 = set(df2.columns)
    
    if cols1 == cols2:
        print("âœ… Sucesso! Os nomes das colunas sÃ£o idÃªnticos em ambos os arquivos.")
        score_colunas = 1.0
    else:
        print("âš ï¸ AtenÃ§Ã£o! Os nomes das colunas sÃ£o diferentes.")
        intersecao = len(cols1.intersection(cols2))
        uniao = len(cols1.union(cols2))
        score_colunas = intersecao / uniao if uniao > 0 else 0.0
        print(f"   Colunas apenas no Arquivo 1: {sorted(list(cols1 - cols2))}")
        print(f"   Colunas apenas no Arquivo 2: {sorted(list(cols2 - cols1))}")
    
    print(f"ğŸ“Š PontuaÃ§Ã£o de Similaridade de Colunas: {score_colunas:.2%}")

    # --- 3. ANÃLISE DE CONTEÃšDO ---
    print("\n---------- ETAPA 3: ANÃLISE DE CONTEÃšDO (CÃ‰LULA A CÃ‰LULA) ----------")
    colunas_comuns = sorted(list(cols1.intersection(cols2)))
    score_conteudo = 0.0

    if not colunas_comuns:
        print(" Sem colunas em comum, a comparaÃ§Ã£o de conteÃºdo nÃ£o Ã© possÃ­vel.")
    else:
        print(f"Comparando o conteÃºdo das {len(colunas_comuns)} colunas em comum...")
        df1_comp = df1[colunas_comuns]
        df2_comp = df2[colunas_comuns]
        
        scores_celulas = []
        linhas_para_comparar = min(len(df1_comp), len(df2_comp))
        
        if linhas_para_comparar > 0:
            for i in range(linhas_para_comparar):
                for col in colunas_comuns:
                    val1 = df1_comp.at[i, col]
                    val2 = df2_comp.at[i, col]
                    s_val1 = str(val1) if pd.notna(val1) else ""
                    s_val2 = str(val2) if pd.notna(val2) else ""
                    
                    # Usa similaridade de texto para todas as colunas
                    score_celula = SequenceMatcher(None, s_val1, s_val2).ratio()
                    scores_celulas.append(score_celula)
            
            if scores_celulas:
                score_conteudo = sum(scores_celulas) / len(scores_celulas)

    print(f"ğŸ“ PontuaÃ§Ã£o de Similaridade de ConteÃºdo: {score_conteudo:.2%}")

    # --- 4. CÃLCULO FINAL PONDERADO ---
    print("\n---------- ETAPA 4: CÃLCULO FINAL PONDERADO ----------")
    print(f"Pesos aplicados -> Estrutura: {peso_estrutura:.0%}, Nomes Colunas: {peso_colunas:.0%}, ConteÃºdo: {peso_conteudo:.0%}")
    
    similaridade_final = (score_estrutura * peso_estrutura) + \
                         (score_colunas * peso_colunas) + \
                         (score_conteudo * peso_conteudo)
    
    print("\n======================================================")
    print(f"ğŸ† SIMILARIDADE FINAL CALCULADA: {similaridade_final:.2%}")
    print("======================================================")
    
    return similaridade_final
