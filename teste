import pandas as pd
import os
from difflib import SequenceMatcher
from typing import Any

# -----------------------------------------------------------------------------
# FUN√á√ïES AUXILIARES (L√ìGICA INTERNA)
# -----------------------------------------------------------------------------

def _carregar_dataframe(caminho_arquivo: str, sheet_name: Any = 0) -> pd.DataFrame:
    """
    Carrega dinamicamente um arquivo (CSV ou Excel) em um DataFrame do Pandas.
    Para Excel, permite a especifica√ß√£o da planilha.
    """
    extensao = os.path.splitext(caminho_arquivo)[1].lower()
    print(f"\nüîÑ Carregando arquivo: '{os.path.basename(caminho_arquivo)}' (extens√£o: {extensao})")

    try:
        if extensao == '.csv':
            return pd.read_csv(caminho_arquivo)
        elif extensao == '.xlsx':
            # Permite carregar uma planilha espec√≠fica
            return pd.read_excel(caminho_arquivo, sheet_name=sheet_name)
        else:
            raise ValueError(f"Extens√£o '{extensao}' n√£o suportada. Use .csv ou .xlsx")
    except FileNotFoundError:
        raise FileNotFoundError(f"ERRO: O arquivo '{caminho_arquivo}' n√£o foi encontrado.")
    except Exception as e:
        raise Exception(f"ERRO ao ler o arquivo '{caminho_arquivo}': {e}")

def _calcular_similaridade(
    df1: pd.DataFrame,
    df2: pd.DataFrame,
    coluna_numerica_obrigatoria: str,
    peso_estrutura: float = 0.3,
    peso_conteudo: float = 0.7
) -> float:
    """
    Recebe dois DataFrames e calcula a similaridade ponderada entre eles.
    Esta √© a fun√ß√£o de c√°lculo principal.
    """
    # --- 1. AN√ÅLISE ESTRUTURAL ---
    print("\n---------- ETAPA 1: AN√ÅLISE ESTRUTURAL ----------")
    shape1 = df1.shape
    shape2 = df2.shape
    print(f"Dimens√µes Arquivo 1: {shape1[0]} linhas, {shape1[1]} colunas.")
    print(f"Dimens√µes Arquivo 2: {shape2[0]} linhas, {shape2[1]} colunas.")

    sim_linhas = min(shape1[0], shape2[0]) / max(shape1[0], shape2[0]) if max(shape1[0], shape2[0]) > 0 else 1.0
    sim_colunas = min(shape1[1], shape2[1]) / max(shape1[1], shape2[1]) if max(shape1[1], shape2[1]) > 0 else 1.0
    
    score_estrutura = (sim_linhas + sim_colunas) / 2
    print(f"Similaridade de Linhas: {sim_linhas:.2%}")
    print(f"Similaridade de Colunas: {sim_colunas:.2%}")
    print(f"üìä Pontua√ß√£o de Similaridade Estrutural: {score_estrutura:.2%}")

    # --- 2. AN√ÅLISE DE CONTE√öDO ---
    print("\n---------- ETAPA 2: AN√ÅLISE DE CONTE√öDO ----------")
    print(f"Verificando correspond√™ncia exata na coluna: '{coluna_numerica_obrigatoria}'")
    print("Calculando similaridade de texto para as demais colunas...")
    
    scores_celulas = []
    linhas_para_comparar = min(shape1[0], shape2[0])
    colunas_para_comparar = min(shape1[1], shape2[1])

    if linhas_para_comparar > 0 and colunas_para_comparar > 0:
        for i in range(linhas_para_comparar):
            for j in range(colunas_para_comparar):
                coluna_atual = df1.columns[j]
                val1 = df1.iloc[i, j]
                val2 = df2.iloc[i, j]
                s_val1 = str(val1) if pd.notna(val1) else ""
                s_val2 = str(val2) if pd.notna(val2) else ""

                if coluna_atual == coluna_numerica_obrigatoria:
                    score_celula = 1.0 if s_val1 == s_val2 else 0.0
                else:
                    score_celula = SequenceMatcher(None, s_val1, s_val2).ratio()
                scores_celulas.append(score_celula)
        
        score_conteudo = sum(scores_celulas) / len(scores_celulas) if scores_celulas else 1.0
    else:
        score_conteudo = 0.0

    print(f"üìù Pontua√ß√£o de Similaridade de Conte√∫do: {score_conteudo:.2%}")

    # --- 3. C√ÅLCULO FINAL ---
    print("\n---------- ETAPA 3: C√ÅLCULO FINAL PONDERADO ----------")
    print(f"Pesos aplicados -> Estrutura: {peso_estrutura:.0%}, Conte√∫do: {peso_conteudo:.0%}")
    
    similaridade_final = (score_estrutura * peso_estrutura) + (score_conteudo * peso_conteudo)
    return similaridade_final

# -----------------------------------------------------------------------------
# FUN√á√ÉO PRINCIPAL (INTERFACE COM O USU√ÅRIO)
# -----------------------------------------------------------------------------

def comparador_dinamico_arquivos(
    caminho_arquivo1: str,
    caminho_arquivo2: str,
    sheet1: Any = 0,
    sheet2: Any = 0
):
    """
    Orquestra a compara√ß√£o din√¢mica e interativa de dois arquivos.
    """
    print("======================================================")
    print("üöÄ INICIANDO COMPARADOR DIN√ÇMICO DE ARQUIVOS üöÄ")
    print("======================================================")

    try:
        # Carregamento e an√°lise din√¢mica inicial
        df1 = _carregar_dataframe(caminho_arquivo1, sheet_name=sheet1)
        print("üîç Colunas detectadas no Arquivo 1:")
        print(f"   {df1.columns.tolist()}")

        df2 = _carregar_dataframe(caminho_arquivo2, sheet_name=sheet2)
        print("üîç Colunas detectadas no Arquivo 2:")
        print(f"   {df2.columns.tolist()}")

        # Identificar colunas em comum para o usu√°rio escolher
        colunas_comuns = sorted(list(set(df1.columns) & set(df2.columns)))
        
        if not colunas_comuns:
            print("\n‚ùå ERRO CR√çTICO: Nenhum nome de coluna em comum encontrado entre os arquivos.")
            return

        print("\n------------------------------------------------------")
        print("Selecione a coluna chave para compara√ß√£o num√©rica:")
        for idx, col in enumerate(colunas_comuns):
            print(f"  [{idx}] {col}")
        
        coluna_escolhida = None
        while coluna_escolhida is None:
            try:
                escolha = int(input("Digite o n√∫mero da coluna desejada: "))
                if 0 <= escolha < len(colunas_comuns):
                    coluna_escolhida = colunas_comuns[escolha]
                else:
                    print("Op√ß√£o inv√°lida. Tente novamente.")
            except (ValueError, IndexError):
                print("Entrada inv√°lida. Digite apenas o n√∫mero correspondente.")
        
        print(f"‚úÖ Coluna chave selecionada: '{coluna_escolhida}'")
        print("------------------------------------------------------")
        
        # Executar o c√°lculo com os dados carregados e a coluna escolhida
        similaridade_final = _calcular_similaridade(df1, df2, coluna_escolhida)
        
        print("\n======================================================")
        print(f"üèÜ SIMILARIDADE FINAL CALCULADA: {similaridade_final:.2%}")
        print("======================================================")

    except (ValueError, FileNotFoundError, Exception) as e:
        print(f"\n‚ùå A an√°lise foi interrompida devido a um erro: {e}")

### Exemplo de Uso Pr√°tico

Vamos criar um arquivo `.csv` e um `.xlsx` para demonstrar a flexibilidade total.

```python
# --- PREPARA√á√ÉO DO AMBIENTE DE TESTE ---
# Criando um arquivo CSV
dados_csv = {
    'COD_PRODUTO': [101, 102, 103, 104],
    'DESCRICAO': ['Mouse Gamer RGB', 'Teclado Mecanico ABNT2', 'Monitor LED 27 polegadas', 'Headset Pro 7.1'],
    'ESTOQUE': [150, 80, 50, 120]
}
df_csv = pd.DataFrame(dados_csv)
df_csv.to_csv("estoque_sistema.csv", index=False)

# Criando um arquivo Excel com dados similares
dados_excel = {
    'COD_PRODUTO': [101, 102, 103, 105], # Um c√≥digo diferente
    'DESCRICAO': ['Mouse Gamer com RGB', 'Teclado Mecanico (formato ABNT2)', 'Monitor de LED 27pol', 'Headset Gamer 7.1 Surround'], # Descri√ß√µes similares
    'ESTOQUE': [150, 79, 50, 90] # Estoque um pouco diferente
}
df_excel = pd.DataFrame(dados_excel)
# Salva na planilha padr√£o (√≠ndice 0)
df_excel.to_excel("relatorio_fornecedor.xlsx", index=False, sheet_name="Dados")


# --- EXECU√á√ÉO DA AN√ÅLISE ---
# Apontamento manual dos arquivos.
# Para o Excel, poder√≠amos especificar a planilha com sheet2="Dados" ou sheet2=0.
# Se n√£o especificarmos, ele pega a primeira por padr√£o.
arquivo_csv = "estoque_sistema.csv"
arquivo_excel = "relatorio_fornecedor.xlsx"

comparador_dinamico_arquivos(arquivo_csv, arquivo_excel)

# --- LIMPEZA DO AMBIENTE ---
os.remove(arquivo_csv)
os.remove(arquivo_excel)
