import pandas as pd
import os
import sys
from difflib import SequenceMatcher
from typing import Any, List, Tuple, Dict
from datetime import datetime

# ==============================================================================
# BLOCO ORIGINAL (INTOCADO, CONFORME SOLICITADO)
# ==============================================================================

def _carregar_dataframe(caminho_arquivo: str, sheet_name: Any = 0) -> pd.DataFrame:
    """
    Carrega dinamicamente um arquivo (CSV ou Excel) em um DataFrame do Pandas.
    Para Excel, permite a especifica√ß√£o da planilha.
    """
    extensao = os.path.splitext(caminho_arquivo)[1].lower()
    print(f"\nüîÑ Carregando arquivo: '{os.path.basename(caminho_arquivo)}' (extens√£o: {extensao})")

    try:
        if extensao == '.csv':
            return pd.read_csv(caminho_arquivo, low_memory=False)
        elif extensao == '.xlsx':
            return pd.read_excel(caminho_arquivo, sheet_name=sheet_name)
        else:
            raise ValueError(f"Extens√£o '{extensao}' n√£o suportada. Use .csv ou .xlsx")
    except FileNotFoundError:
        raise FileNotFoundError(f"ERRO: O arquivo '{caminho_arquivo}' n√£o foi encontrado.")
    except Exception as e:
        raise Exception(f"ERRO ao ler o arquivo '{caminho_arquivo}': {e}")

def comparador_avancado_arquivos(
    caminho_arquivo1: str,
    caminho_arquivo2: str,
    sheet1: Any = 0,
    sheet2: Any = 0,
    peso_estrutura: float = 0.3,
    peso_colunas: float = 0.4,
    peso_conteudo: float = 0.3
) -> float:
    """
    Compara de forma avan√ßada e totalmente autom√°tica a similaridade entre dois arquivos.

    A an√°lise √© baseada em tr√™s pilares com pesos ajust√°veis:
    1.  **Estrutura:** Compara a quantidade de linhas e colunas.
    2.  **Nomes das Colunas:** Verifica se o conjunto de colunas √© id√™ntico.
    3.  **Conte√∫do:** Compara c√©lula a c√©lula o conte√∫do das colunas em comum.

    Args:
        caminho_arquivo1 (str): Caminho completo para o primeiro arquivo.
        caminho_arquivo2 (str): Caminho completo para o segundo arquivo.
        sheet1 (Any): Planilha a ser lida no primeiro arquivo, se for .xlsx (padr√£o 0).
        sheet2 (Any): Planilha a ser lida no segundo arquivo, se for .xlsx (padr√£o 0).
        peso_estrutura (float): Peso da similaridade estrutural (padr√£o 0.3).
        peso_colunas (float): Peso da similaridade dos nomes das colunas (padr√£o 0.4).
        peso_conteudo (float): Peso da similaridade do conte√∫do (padr√£o 0.3).

    Returns:
        float: O percentual final de similaridade entre os dois arquivos.
    """
    print("======================================================")
    print(f"üöÄ INICIANDO COMPARA√á√ÉO AVAN√áADA ENTRE '{os.path.basename(caminho_arquivo1)}' E '{os.path.basename(caminho_arquivo2)}' üöÄ")
    print("======================================================")
    
    try:
        df1 = _carregar_dataframe(caminho_arquivo1, sheet_name=sheet1)
        df2 = _carregar_dataframe(caminho_arquivo2, sheet_name=sheet2)
    except (ValueError, FileNotFoundError, Exception) as e:
        print(f"\n‚ùå A an√°lise foi interrompida devido a um erro de carregamento: {e}")
        return 0.0

    # --- 1. AN√ÅLISE ESTRUTURAL (DIMENS√ïES) ---
    print("\n---------- ETAPA 1: AN√ÅLISE ESTRUTURAL (DIMENS√ïES) ----------")
    shape1 = df1.shape
    shape2 = df2.shape
    print(f"Dimens√µes Arquivo 1: {shape1[0]} linhas, {shape1[1]} colunas.")
    print(f"Dimens√µes Arquivo 2: {shape2[0]} linhas, {shape2[1]} colunas.")
    
    sim_linhas = min(shape1[0], shape2[0]) / max(shape1[0], shape2[0]) if max(shape1[0], shape2[0]) > 0 else 1.0
    sim_colunas_total = min(shape1[1], shape2[1]) / max(shape1[1], shape2[1]) if max(shape1[1], shape2[1]) > 0 else 1.0
    score_estrutura = (sim_linhas + sim_colunas_total) / 2
    print(f"üìä Pontua√ß√£o de Similaridade Estrutural: {score_estrutura:.2%}")

    # --- 2. AN√ÅLISE DOS NOMES DAS COLUNAS ---
    print("\n---------- ETAPA 2: AN√ÅLISE DOS NOMES DAS COLUNAS ----------")
    cols1 = set(df1.columns)
    cols2 = set(df2.columns)
    
    if cols1 == cols2:
        print("‚úÖ Sucesso! Os nomes das colunas s√£o id√™nticos em ambos os arquivos.")
        score_colunas = 1.0
    else:
        print("‚ö†Ô∏è Aten√ß√£o! Os nomes das colunas s√£o diferentes.")
        intersecao = len(cols1.intersection(cols2))
        uniao = len(cols1.union(cols2))
        score_colunas = intersecao / uniao if uniao > 0 else 0.0
        print(f"   Colunas apenas no Arquivo 1: {sorted(list(cols1 - cols2))}")
        print(f"   Colunas apenas no Arquivo 2: {sorted(list(cols2 - cols1))}")
    
    print(f"üìä Pontua√ß√£o de Similaridade de Colunas: {score_colunas:.2%}")

    # --- 3. AN√ÅLISE DE CONTE√öDO ---
    print("\n---------- ETAPA 3: AN√ÅLISE DE CONTE√öDO (C√âLULA A C√âLULA) ----------")
    colunas_comuns = sorted(list(cols1.intersection(cols2)))
    score_conteudo = 0.0

    if not colunas_comuns:
        print(" Sem colunas em comum, a compara√ß√£o de conte√∫do n√£o √© poss√≠vel.")
    else:
        print(f"Comparando o conte√∫do das {len(colunas_comuns)} colunas em comum...")
        df1_comp = df1[colunas_comuns]
        df2_comp = df2[colunas_comuns]
        
        scores_celulas = []
        linhas_para_comparar = min(len(df1_comp), len(df2_comp))
        
        if linhas_para_comparar > 0:
            for i in range(linhas_para_comparar):
                for col in colunas_comuns:
                    val1 = df1_comp.at[i, col]
                    val2 = df2_comp.at[i, col]
                    s_val1 = str(val1) if pd.notna(val1) else ""
                    s_val2 = str(val2) if pd.notna(val2) else ""
                    
                    # Usa similaridade de texto para todas as colunas
                    score_celula = SequenceMatcher(None, s_val1, s_val2).ratio()
                    scores_celulas.append(score_celula)
            
            if scores_celulas:
                score_conteudo = sum(scores_celulas) / len(scores_celulas)

    print(f"üìù Pontua√ß√£o de Similaridade de Conte√∫do: {score_conteudo:.2%}")

    # --- 4. C√ÅLCULO FINAL PONDERADO ---
    print("\n---------- ETAPA 4: C√ÅLCULO FINAL PONDERADO ----------")
    print(f"Pesos aplicados -> Estrutura: {peso_estrutura:.0%}, Nomes Colunas: {peso_colunas:.0%}, Conte√∫do: {peso_conteudo:.0%}")
    
    similaridade_final = (score_estrutura * peso_estrutura) + \
                         (score_colunas * peso_colunas) + \
                         (score_conteudo * peso_conteudo)
    
    print("\n======================================================")
    print(f"üèÜ SIMILARIDADE FINAL CALCULADA: {similaridade_final:.2%}")
    print("======================================================")
    
    return similaridade_final

# ==============================================================================
# BLOCO NOVO: ORQUESTRA√á√ÉO, PAREAMENTO E LOGGING
# ==============================================================================

class Logger(object):
    """
    Classe para redirecionar a sa√≠da (stdout) para um arquivo de log e para o terminal.
    """
    def __init__(self, nome_arquivo="log_comparacao.txt"):
        self.terminal = sys.stdout
        self.log = open(nome_arquivo, "w", encoding='utf-8')

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)

    def flush(self):
        self.terminal.flush()
        self.log.flush()

def _analisar_metadados_diretorio(caminho_dir: str) -> List[Dict[str, Any]]:
    """
    L√™ um diret√≥rio e extrai metadados (caminho, forma, colunas) de cada arquivo.
    """
    metadados = []
    print(f"\nüîé Analisando metadados do diret√≥rio: '{caminho_dir}'")
    for nome_arquivo in os.listdir(caminho_dir):
        caminho_completo = os.path.join(caminho_dir, nome_arquivo)
        if os.path.isfile(caminho_completo) and (nome_arquivo.endswith('.csv') or nome_arquivo.endswith('.xlsx')):
            try:
                # Usamos uma fun√ß√£o de carregamento silenciosa para n√£o poluir o log de metadados
                df = _carregar_dataframe_silencioso(caminho_completo)
                metadados.append({
                    "caminho": caminho_completo,
                    "shape": df.shape,
                    "colunas": set(df.columns)
                })
                print(f"  - Metadados de '{nome_arquivo}' extra√≠dos com sucesso.")
            except Exception as e:
                print(f"  - ‚ùå Falha ao ler metadados de '{nome_arquivo}': {e}")
    return metadados

def _carregar_dataframe_silencioso(caminho_arquivo: str) -> pd.DataFrame:
    """Vers√£o simplificada para carregar DF sem imprimir na tela."""
    extensao = os.path.splitext(caminho_arquivo)[1].lower()
    if extensao == '.csv':
        return pd.read_csv(caminho_arquivo, low_memory=False)
    elif extensao == '.xlsx':
        return pd.read_excel(caminho_arquivo)
    raise ValueError("Extens√£o n√£o suportada.")


def encontrar_pares_de_arquivos(
    meta_dir_a: List[Dict[str, Any]],
    meta_dir_b: List[Dict[str, Any]],
    limiar_similaridade_previa: float = 0.75
) -> Tuple[List[Tuple[str, str]], List[str], List[str]]:
    """
    Encontra os melhores pares de arquivos entre dois diret√≥rios com base na similaridade
    de estrutura (dimens√µes) e nomes de colunas.
    """
    print("\nü§ù Iniciando o processo de pareamento de arquivos entre os diret√≥rios...")
    
    pares_encontrados = []
    arquivos_b_disponiveis = meta_dir_b[:]
    arquivos_a_pareados = set()

    for meta_a in meta_dir_a:
        melhor_par = None
        maior_score = -1

        for meta_b in arquivos_b_disponiveis:
            # Calcular similaridade de colunas (Jaccard)
            intersecao = len(meta_a["colunas"].intersection(meta_b["colunas"]))
            uniao = len(meta_a["colunas"].union(meta_b["colunas"]))
            score_colunas = intersecao / uniao if uniao > 0 else 0.0

            # Calcular similaridade de dimens√µes (shape)
            shape_a = meta_a["shape"]
            shape_b = meta_b["shape"]
            sim_colunas_total = min(shape_a[1], shape_b[1]) / max(shape_a[1], shape_b[1]) if max(shape_a[1], shape_b[1]) > 0 else 1.0
            
            # Score combinado: A similaridade das colunas √© mais importante para a identidade do arquivo.
            score_combinado = (score_colunas * 0.7) + (sim_colunas_total * 0.3)

            if score_combinado > maior_score:
                maior_score = score_combinado
                melhor_par = meta_b

        if melhor_par and maior_score >= limiar_similaridade_previa:
            pares_encontrados.append((meta_a["caminho"], melhor_par["caminho"]))
            arquivos_a_pareados.add(meta_a["caminho"])
            arquivos_b_disponiveis.remove(melhor_par)
            print(f"  - Par encontrado: '{os.path.basename(meta_a['caminho'])}' <=> '{os.path.basename(melhor_par['caminho'])}' (Score pr√©vio: {maior_score:.2%})")

    # Identificar arquivos que n√£o foram pareados
    nao_pareados_a = [meta["caminho"] for meta in meta_dir_a if meta["caminho"] not in arquivos_a_pareados]
    nao_pareados_b = [meta["caminho"] for meta in arquivos_b_disponiveis]

    return pares_encontrados, nao_pareados_a, nao_pareados_b


def processar_comparacao_entre_diretorios(dir_a: str, dir_b: str):
    """
    Fun√ß√£o principal que orquestra todo o processo de compara√ß√£o entre dois diret√≥rios.
    """
    # Configura o logger
    nome_log = f"log_comparacao_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    sys.stdout = Logger(nome_log)
    
    print("######################################################")
    print("### IN√çCIO DA EXECU√á√ÉO DO COMPARADOR DE DIRET√ìRIOS ###")
    print("######################################################\n")
    print(f"Diret√≥rio A: {dir_a}")
    print(f"Diret√≥rio B: {dir_b}")
    print(f"Log sendo salvo em: {nome_log}\n")

    # Etapa 1: Extrair metadados de ambos os diret√≥rios
    metadados_a = _analisar_metadados_diretorio(dir_a)
    metadados_b = _analisar_metadados_diretorio(dir_b)

    # Etapa 2: Encontrar os pares correspondentes
    pares, nao_pareados_a, nao_pareados_b = encontrar_pares_de_arquivos(metadados_a, metadados_b)

    # Etapa 3: Executar a compara√ß√£o avan√ßada para cada par
    print("\n\n######################################################")
    print("###     INICIANDO COMPARA√á√ïES DETALHADAS     ###")
    print("######################################################")
    
    resultados_finais = {}
    if not pares:
        print("\nNenhum par de arquivos foi encontrado para compara√ß√£o detalhada.")
    else:
        for caminho1, caminho2 in pares:
            similaridade = comparador_avancado_arquivos(caminho1, caminho2)
            resultados_finais[f"{os.path.basename(caminho1)} vs {os.path.basename(caminho2)}"] = similaridade
            print("\n\n") # Espa√ßamento entre as compara√ß√µes

    # Etapa 4: Apresentar o resumo final no log
    print("\n\n######################################################")
    print("###              RESUMO DA EXECU√á√ÉO              ###")
    print("######################################################\n")
    
    print("--- Resultados das Compara√ß√µes ---")
    if resultados_finais:
        for par, score in resultados_finais.items():
            print(f"- {par}: {score:.2%}")
    else:
        print("Nenhuma compara√ß√£o foi executada.")
        
    print("\n--- Arquivos Sem Par no Diret√≥rio A ---")
    if nao_pareados_a:
        for arq in nao_pareados_a:
            print(f"- {os.path.basename(arq)}")
    else:
        print("Todos os arquivos do Diret√≥rio A foram pareados.")

    print("\n--- Arquivos Sem Par no Diret√≥rio B ---")
    if nao_pareados_b:
        for arq in nao_pareados_b:
            print(f"- {os.path.basename(arq)}")
    else:
        print("Todos os arquivos do Diret√≥rio B foram pareados.")
        
    print("\n\n######################################################")
    print("###           EXECU√á√ÉO FINALIZADA                ###")
    print("######################################################")

# ==============================================================================
# BLOCO DE EXECU√á√ÉO E EXEMPLO
# ==============================================================================
if __name__ == '__main__':
    # --- Cria√ß√£o de um ambiente de teste com diret√≥rios e arquivos de exemplo ---
    print("Configurando ambiente de teste...")
    
    # Criando diret√≥rios
    dir_a = "diretorio_A"
    dir_b = "diretorio_B"
    os.makedirs(dir_a, exist_ok=True)
    os.makedirs(dir_b, exist_ok=True)

    # Criando DataFrames de exemplo
    df_clientes_orig = pd.DataFrame({
        'ID_Cliente': [101, 102, 103, 104],
        'Nome': ['Alice', 'Bruno', 'Carlos', 'Diana'],
        'Idade': [34, 25, 45, 29]
    })
    
    df_clientes_novo_nome = df_clientes_orig.copy()
    df_clientes_novo_nome.at[2, 'Nome'] = 'Carla' # Pequena altera√ß√£o no conte√∫do

    df_produtos = pd.DataFrame({
        'SKU': ['A-001', 'B-002', 'C-003'],
        'Produto': ['Notebook', 'Mouse', 'Teclado'],
        'Preco': [4500.00, 150.50, 299.90]
    })
    
    df_vendas_a = pd.DataFrame({'Data': ['2025-01-10'], 'Valor': [1000]})
    df_fornecedores_b = pd.DataFrame({'CNPJ': ['123456/0001-00'], 'Empresa': ['Fornecedor X']})

    # Salvando os arquivos com nomes diferentes nos diret√≥rios
    df_clientes_orig.to_csv(os.path.join(dir_a, "base_clientes_jan.csv"), index=False)
    df_produtos.to_excel(os.path.join(dir_a, "catalogo_produtos.xlsx"), index=False)
    df_vendas_a.to_csv(os.path.join(dir_a, "relatorio_vendas.csv"), index=False) # Arquivo sem par

    df_clientes_novo_nome.to_csv(os.path.join(dir_b, "customer_data_01.csv"), index=False)
    df_produtos.to_excel(os.path.join(dir_b, "product_catalog_v2.xlsx"), index=False)
    df_fornecedores_b.to_csv(os.path.join(dir_b, "dados_fornecedores.csv"), index=False) # Arquivo sem par

    print("Ambiente de teste configurado.\n")
    
    # --- Execu√ß√£o da fun√ß√£o principal ---
    # A partir daqui, toda a sa√≠da ser√° capturada pelo logger
    processar_comparacao_entre_diretorios(dir_a, dir_b)
